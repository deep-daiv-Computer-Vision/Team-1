import streamlit as st
import pandas as pd
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from umap import UMAP
import plotly.express as px
from sentence_transformers import SentenceTransformer

def render_right_sidebar():
    # 카테고리별 단어 리스트
    dfs_words = [
    "깊이우선탐색", "트리탐색", "노드추적", "재귀호출", "스택자료구조", "그래프순회", "백트래킹", "트리구조", "자식노드", "루트노드",
    "순환구조", "그래프탐색", "순환호출", "스택기반탐색", "노드방문", "재귀조건", "노드추적방식", "자식노드순회", "루프제어", "역방향탐색",
    "깊이탐색", "그래프이론", "DFS구현", "트리분할", "순환탐색", "후위순회", "재귀적탐색", "부모노드", "스택활용", "노드스택",
    "깊이제어", "그래프경로", "자식노드방문", "재귀로직", "탐색상태", "스택추적", "노드스택연결", "그래프구조순회", "후속노드", "탐색순서설정",
    "깊이한정탐색", "노드연결상태", "스택기반구현", "순회방문", "노드경로", "트리탐색구조", "루프구조", "순차탐색", "스택연산", "깊이우선순회",
    "깊이우선알고리즘", "경로순회", "스택활용방법", "그래프방문", "스택트리", "재귀적구조", "그래프재귀", "노드상태저장", "트리탐색방법", "노드상태추적",
    "루트순회", "자식방문", "스택방문", "재귀적으로탐색", "노드집합", "탐색구조", "스택노드", "트리방향", "노드재귀", "깊이한정",
    "재귀호출구조", "그래프순회구조", "깊이기반탐색", "노드방향", "스택과큐", "루프점검", "순회로직", "DFS코드", "스택구현", "그래프재귀탐색",
    "스택모델", "순환탐색구조", "재귀트리", "그래프기반탐색", "스택노드활용", "스택정렬", "탐색모델", "스택상태", "트리노드", "트리추적",
    "스택상태저장", "스택순환", "그래프순환", "재귀구현", "깊이우선구조", "탐색효율성", "노드그래프", "순회경로", "스택기반재귀", "탐색분석"
    ]

    bfs_words = [
    "너비우선탐색", "큐자료구조", "레벨탐색", "그래프탐험", "연결탐색", "그래프순환", "최단경로탐색", "노드큐", "차례탐색", "방문기록",
    "큐기반탐색", "탐색레벨", "인접노드탐색", "연결노드탐험", "노드추적방식", "탐색순서", "인접리스트", "그래프구조탐험", "레벨별방문", "연결방향탐색",
    "큐구현", "순차큐", "그래프큐", "큐순회", "너비경로", "탐색방향", "레벨방문", "큐기반순회", "그래프구조순회", "큐노드",
    "너비탐색구현", "노드연결", "큐상태저장", "레벨구조", "그래프큐탐험", "탐색로직", "큐자료구조활용", "연결구조", "그래프방문", "큐사용",
    "탐색노드", "큐탐색", "너비순서탐색", "레벨분할", "그래프노드", "노드방문구조", "레벨기반탐험", "큐순환", "노드순서", "큐구조활용",
    "큐상태", "노드순서저장", "큐탐험", "탐색큐", "그래프레벨", "너비순회", "노드레벨", "큐상태추적", "노드정렬", "그래프경로",
    "레벨구조탐색", "큐순서활용", "너비기반순회", "큐경로탐색", "연결큐", "큐순환탐험", "그래프레벨탐험", "큐활용방법", "그래프순회", "큐노드연결",
    "레벨탐험", "큐추적", "탐색경로", "노드레벨방문", "큐노드탐험", "큐데이터", "그래프연결", "노드연결탐험", "너비우선탐험", "큐구조탐험",
    "레벨구조연결", "큐순환구현", "그래프노드탐험", "큐레벨활용", "노드경로저장", "큐경로저장", "노드탐색", "그래프레벨분석", "큐활용탐색", "너비탐험"
    ]

    sort_words = [
    "정렬알고리즘", "버블정렬", "선택정렬", "삽입정렬", "합병정렬", "퀵정렬", "힙정렬", "기수정렬", "쉘정렬", "배열정렬",
    "리스트정렬", "정렬비교", "순서배치", "원소배열", "정렬구조", "배열조작", "정렬순서", "데이터정렬", "키값정렬", "값변경정렬",
    "정렬속도", "정렬방식", "정렬절차", "정렬방법", "정렬코드", "배열정렬구조", "리스트정렬방법", "정렬시작", "정렬종료", "정렬조건",
    "정렬효율성", "정렬시간복잡도", "배열순서", "데이터배치", "원소정렬", "정렬결과", "정렬작업", "배열최적화", "정렬구현", "정렬종류",
    "병합정렬", "분할정복정렬", "정렬로직", "정렬연산", "정렬이해", "정렬모델", "정렬방식선택", "정렬실행", "정렬문제", "정렬패턴",
    "정렬데이터", "정렬키값", "정렬기준", "정렬조건설정", "정렬과정", "정렬분석", "정렬원리", "정렬알고리즘분석", "정렬순환", "정렬성능",
    "정렬디버깅", "정렬결과확인", "정렬방법분석", "정렬비교실험", "정렬효율비교", "정렬데이터활용", "정렬로직분석", "정렬과정설명", "정렬조건분석", "정렬효율성확인",
    "정렬분석방법", "정렬시간측정", "정렬종류선택", "정렬코드구현", "정렬결과분석", "정렬이론", "정렬연산분석", "정렬로직구현", "정렬모델활용", "정렬분할",
    "정렬테스트", "정렬실험", "정렬결과데이터", "정렬배열분석", "정렬데이터구조", "정렬로직디버깅", "정렬코드작성", "정렬분석보고서", "정렬디자인", "정렬성과분석"
    ]   

    greedy_words = [
    "탐욕적선택", "최적해구성", "지역해결정", "전역최적화", "비용최소화", "최적해탐색", "부분최적해", "탐욕전략", "최대가치선택", "우선선택",
    "탐욕적접근", "해결전략", "탐욕적분석", "최적해결", "최적화알고리즘", "탐욕해결법", "최적문제", "탐욕구현", "탐욕패턴", "탐욕적최적화",
    "최적문제해결", "탐욕적구조", "탐욕적단계", "최적경로", "탐욕적방법", "최적성과", "탐욕적방식", "탐욕적구성", "탐욕적비용", "탐욕적순서",
    "탐욕적분할", "탐욕적탐색", "탐욕적결정", "탐욕적전략", "탐욕적방법론", "탐욕적선택조건", "탐욕적구조구성", "탐욕적결과", "탐욕적패턴",
    "탐욕적계산", "탐욕적분석법", "탐욕적최적화전략", "탐욕적경로", "탐욕적최적화조건", "탐욕적비용최소화", "탐욕적효율성", "탐욕적구조분석",
    "탐욕적최적경로", "탐욕적연산", "탐욕적모델", "탐욕적실험", "탐욕적최적조건", "탐욕적문제해결", "탐욕적시간복잡도", "탐욕적효율비교", "탐욕적최적성",
    "탐욕적비용최적화", "탐욕적해결법", "탐욕적해결방법", "탐욕적알고리즘", "탐욕적코드", "탐욕적구조구현", "탐욕적디자인", "탐욕적패턴구조", "탐욕적효율성분석",
    "탐욕적비용최소조건", "탐욕적최적화구조", "탐욕적탐색조건", "탐욕적분석구조", "탐욕적결과분석", "탐욕적구성방법", "탐욕적문제구현", "탐욕적모델구조",
    "탐욕적구조설계", "탐욕적알고리즘구현", "탐욕적시간최적화", "탐욕적결정조건", "탐욕적경로탐색", "탐욕적연산구현", "탐욕적설계패턴", "탐욕적최적해구현",
    "탐욕적전략구성", "탐욕적문제설계", "탐욕적해결분석", "탐욕적최적화분석", "탐욕적조건설정", "탐욕적코드작성", "탐욕적구조분석방법", "탐욕적최적성구조",
    "탐욕적결과확인", "탐욕적최적조건분석", "탐욕적구조디자인", "탐욕적최적성분석", "탐욕적결과데이터"
    ]   

    dp_words = [
    "동적계획법", "부분문제", "최적부분구조", "메모이제이션", "캐시활용", "점화식", "하위문제", "최적화구조", "최적결과", "DP알고리즘",
    "상향식", "하향식", "중복계산제거", "문제분할", "부분해결", "최적구조", "DP구현", "DP효율성", "DP활용", "DP패턴",
    "문제구조", "부분최적화", "최적구현", "최적문제구조", "부분구조활용", "최적화패턴", "하위해결", "메모리효율", "최적값", "부분문제결정",
    "최적해구조", "DP분석", "점화식구성", "최적화분할", "최적해탐색", "부분문제구성", "DP시간복잡도", "DP코드", "부분구조분석", "최적결과탐색",
    "DP로직", "DP모델", "최적문제해결", "DP디자인", "DP효율분석", "DP조건", "점화식분석", "부분해결법", "최적해결구조", "DP연산",
    "부분문제분석", "최적해설정", "DP탐색", "최적조건", "DP구조", "최적문제분석", "부분구조해결", "DP최적화", "DP구조분석", "점화식활용",
    "최적화모델", "DP실험", "DP결과", "최적조건분석", "DP분석방법", "최적화설계", "부분구조최적화", "최적화구현", "DP구현법", "DP디버깅",
    "DP패턴구조", "최적조건구성", "DP활용방법", "최적화분할구조", "DP구조구현", "최적해분석", "DP최적조건", "최적화구조분석", "DP결과분석",
    "DP시간효율성", "부분해결구조", "DP효율성분석", "최적화문제", "부분구조탐색", "DP로직분석", "DP구조설계", "최적조건설정", "DP최적화패턴",
    "DP최적성분석", "최적해결방법", "부분문제해결", "DP구현구조", "DP구조활용", "최적해탐색방법", "DP시간최적화", "DP구조모델", "DP효율최적화"
    ]

    shortest_path_words = [
    "최단거리", "다익스트라", "벨만포드", "플로이드와샬", "그래프가중치", "경로최적화", "가중치그래프", "경로탐색", "그래프알고리즘", "최소경로",
    "거리계산", "최단경로탐색", "가중치계산", "경로분석", "최단거리계산", "그래프구조", "경로효율성", "경로최적화조건", "최소비용", "최소거리",
    "최단경로구현", "경로탐색구조", "경로연산", "최적경로탐색", "그래프경로", "가중치분석", "경로구조", "최단거리탐색", "경로데이터", "경로구현",
    "최단경로로직", "그래프데이터", "최적화경로", "최단경로효율성", "최단경로계산", "경로효율", "그래프탐색구조", "가중치데이터", "경로연결", "경로분석방법",
    "최단경로분석", "최소경로계산", "그래프경로탐색", "최단경로시간", "최단경로분할", "그래프연산", "경로최적화구조", "최단경로패턴", "최적경로계산", "경로탐색모델",
    "최단경로조건", "경로효율분석", "그래프경로효율", "최적화경로탐색", "경로탐색법", "최단경로설계", "그래프효율분석", "경로계산구조", "최단경로활용", "그래프분석",
    "최소가중치", "최소비용계산", "경로시간최적화", "최단경로실험", "최단경로데이터", "경로구조탐색", "경로최적화알고리즘", "경로구조분석", "최단경로설정",
    "그래프구조분석", "최소가중치경로", "경로분석구조", "최단경로연산", "그래프경로최적화", "최단경로조건분석", "경로구조설계", "최단경로데이터구조", "경로분석효율성",
    "최단거리조건", "최적경로연산", "최소비용분석", "최단경로효율", "최단경로시간최적화", "경로최적화구현", "경로효율성분석", "최적경로분석", "경로구조설계방법",
    "최단경로디자인", "그래프구조탐색", "최단경로모델", "최소비용경로", "최단경로구조", "그래프구조연결", "경로분석모델", "최소가중치구조", "최단거리분석"
    ]

    model = SentenceTransformer('jhgan/ko-sroberta-multitask')

    # 모든 단어와 카테고리 데이터프레임 생성
    categories = ['DFS'] * len(dfs_words) + ['BFS'] * len(bfs_words) + ['Sort'] * len(sort_words) + \
                 ['Greedy'] * len(greedy_words) + ['DP'] * len(dp_words) + ['Shortest Path'] * len(shortest_path_words)

    words = dfs_words + bfs_words + sort_words + greedy_words + dp_words + shortest_path_words
    df = pd.DataFrame({'Word': words, 'Category': categories})

    # 텍스트 임베딩 (Sentence Transformer)
    embeddings = model.encode(df['Word'].tolist(), show_progress_bar=True)
    
    # 차원 축소 (UMAP)
    umap_model = UMAP(n_neighbors=15, min_dist=0.1, metric='cosine')
    embedding = umap_model.fit_transform(embeddings)

    # 결과를 데이터프레임에 저장
    df['UMAP_1'] = embedding[:, 0]
    df['UMAP_2'] = embedding[:, 1]

    # Streamlit 사이드바 및 UI
    st.sidebar.title("Algorithm Word Categories")
    selected_categories = st.sidebar.multiselect(
        "Select categories to display:",
        options=df['Category'].unique(),
        default=df['Category'].unique()
    )

    # 선택한 카테고리 필터링
    filtered_df = df[df['Category'].isin(selected_categories)]

    # Plotly 시각화
    fig = px.scatter(
        filtered_df,
        x='UMAP_1',
        y='UMAP_2',
        color='Category',
        text='Word',
        title="Algorithm Word Embedding Visualization",
        labels={'UMAP_1': 'Dimension 1', 'UMAP_2': 'Dimension 2'},
        hover_data=['Word']
    )

    st.plotly_chart(fig, use_container_width=True)